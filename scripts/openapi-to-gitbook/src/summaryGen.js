'use strict';

const fs = require('fs');
const path = require('path');
const { getTagLabel } = require('./domainMapper');
const { AUTO_MARKER } = require('./markdownGen');

const START_MARKER = '<!-- AUTO-GENERATED-START -->';
const END_MARKER = '<!-- AUTO-GENERATED-END -->';

function scanAutoGeneratedFiles(outputDir) {
  const endpoints = [];

  let entries;
  try {
    entries = fs.readdirSync(outputDir, { withFileTypes: true });
  } catch {
    return endpoints;
  }

  const dirs = entries.filter(d => d.isDirectory()).map(d => d.name);

  for (const dir of dirs) {
    const dirPath = path.join(outputDir, dir);
    let files;
    try {
      files = fs.readdirSync(dirPath).filter(f => f.endsWith('.md'));
    } catch {
      continue;
    }

    for (const file of files) {
      const content = fs.readFileSync(path.join(dirPath, file), 'utf-8');
      if (!content.startsWith(AUTO_MARKER)) continue;

      const titleMatch = content.match(/^## (.+)$/m);
      const title = titleMatch ? titleMatch[1] : file.replace('.md', '');

      endpoints.push({ dir, fileName: file, title, tag: getTagLabel(dir) });
    }
  }

  return endpoints;
}

function buildAutoSection(endpoints) {
  const groups = {};
  for (const ep of endpoints) {
    if (!groups[ep.dir]) {
      groups[ep.dir] = { label: ep.tag, items: [] };
    }
    groups[ep.dir].items.push(ep);
  }

  const lines = [START_MARKER, ''];

  const sortedDirs = Object.keys(groups).sort();
  for (const dir of sortedDirs) {
    const group = groups[dir];
    lines.push(`## ${group.label}`, '');
    for (const item of group.items) {
      lines.push(`* [${item.title}](${dir}/${item.fileName})`);
    }
    lines.push('');
  }

  lines.push(END_MARKER);
  return lines.join('\n');
}

function scanAndMergeSummary(outputDir) {
  const endpoints = scanAutoGeneratedFiles(outputDir);
  if (endpoints.length === 0) return;

  const summaryPath = path.join(outputDir, 'SUMMARY.md');
  const autoSection = buildAutoSection(endpoints);

  if (!fs.existsSync(summaryPath)) {
    const content = `# Table of contents\n\n* [소개](README.md)\n\n${autoSection}\n`;
    fs.writeFileSync(summaryPath, content, 'utf-8');
    return;
  }

  const existing = fs.readFileSync(summaryPath, 'utf-8');
  const startIdx = existing.indexOf(START_MARKER);
  const endIdx = existing.indexOf(END_MARKER);

  let merged;
  if (startIdx !== -1 && endIdx !== -1) {
    const before = existing.substring(0, startIdx);
    const after = existing.substring(endIdx + END_MARKER.length);
    merged = before + autoSection + after;
  } else {
    merged = existing.trimEnd() + '\n\n' + autoSection + '\n';
  }

  fs.writeFileSync(summaryPath, merged, 'utf-8');
}

module.exports = { scanAndMergeSummary };
